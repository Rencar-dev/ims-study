# 반복자 패턴과 컴포지트 패턴.

## 반복자 패턴

### 정의

- 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공.
- 각 항목에 일일히 접근하는 접근자 객체와 집합체 인터페이스를 분리할 수 있음.

### 구조

- `Aggregate`
  - 인터페이스
  - `createIterator()`
- `ConcreteAggregate`
  - 객체 컬렉션이 들어있음.
  - `createIterator()`
    - `ConcreteIterator` 인스턴스를 반환.
- `Iterator`
  - 모든 반복자가 구현해야하는 인터페이스.
  - 컬렉션에 들어있는 원소를 돌아가면서 접근할 수 있게하는 메소드를 제공.
  - `hasNext()`, `next()`, `remove()`
- `ConcreteIterator`
  - 반복 작업 중에 현재 위치를 관리.ㅌㅈ

### 단일 역할 원칙

- 어떤 클래스가 바뀌는 이유는 하나뿐이어야 한다.
- 하나의 클래스는 하나의 역할만 맡아야 한다.

## 컴포지트 패턴

### 정의

- 객체를 트리구조로 구성해서 부분-전체 계층구조를 구현.
  - ex) 메뉴 - 서브 메뉴.
- 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있음.
  - 복합 객체와 개별 객체를 구분할 필요가 없음.

### 구조

- `Client`
  - `Component` 인터페이스를 사용해서 복합 객체 내의 객체들을 조작.
- `Component`
  - 복합 객체 내에 들어 있는 모든 객체의 인터페이스를 정의.
    `add()`, `remove()`, `getChild()` 등 몇 가지 작업의 기본 행동을 정의할 수 있음.
- `Leaf`
  - 그 안에 들어있는 원소의 행동을 정의.
  - `Composite`에서 지원하는 기능을 구현.
  - 자식이 없음.
- `Composite`
  - 자식이 있는 구성 요소의 행동을 정의하고 자식 구성 요소를 저장하는 역할.
  - `Leaf`와 관련된 기능도 구현.
    - 복합 객체에게 별 쓸모가 없으면 예외를 던지는 방법도 가능.
